<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>RUN</title>
    <style>
        body { 
            margin: 0; overflow: hidden; background-color: #050505; color: #fff; 
            font-family: 'Courier New', Courier, monospace; 
            touch-action: none; user-select: none; -webkit-user-select: none;
        }
        canvas { display: block; cursor: crosshair; }
        
        /* UI Layer */
        #ui-layer { position: absolute; top: 20px; left: 20px; pointer-events: none; z-index: 10; width: 90%; }
        
        /* Main Title */
        #game-title {
            font-size: 40px; font-weight: 900; letter-spacing: 10px; color: #fff;
            text-shadow: 4px 4px 0px #0ff; font-style: italic; margin-bottom: 10px;
        }

        .hud-text { font-size: 18px; font-weight: bold; text-shadow: 0 0 5px #000; margin-bottom: 5px; }
        #score { color: #0ff; font-size: 24px; }
        #high-score { color: #ff0; font-size: 16px; opacity: 0.8; }
        
        #dash-indicator {
            position: absolute; top: 20px; right: 20px; 
            width: 20px; height: 20px; border-radius: 50%; 
            background: #555; border: 2px solid #fff;
            box-shadow: 0 0 10px #000;
        }
        #dash-indicator.ready { background: #0ff; box-shadow: 0 0 15px #0ff; }

        #game-over {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; display: none; background: rgba(0,0,0,0.95); padding: 40px; 
            border: 4px solid #fff; z-index: 20; width: 85%; max-width: 400px;
        }
        h1 { margin: 0 0 10px 0; text-transform: uppercase; letter-spacing: 2px; font-size: 32px; color: #f00; font-style: italic;}
        button.restart-btn { 
            background: #fff; color: #000; border: none; padding: 15px 30px; 
            font-size: 24px; cursor: pointer; font-weight: 900; width: 100%; text-transform: uppercase;
            font-style: italic;
        }
        button.restart-btn:hover { background: #0ff; }

        /* Mobile Controls */
        #mobile-controls {
            position: absolute; bottom: 30px; left: 0; width: 100%; height: 100px;
            display: flex; justify-content: space-between; padding: 0 30px; box-sizing: border-box;
            z-index: 15; pointer-events: none; 
        }
        .control-group { display: flex; gap: 20px; pointer-events: auto; }
        .touch-btn {
            width: 70px; height: 70px; background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3); border-radius: 50%;
            color: #fff; font-size: 24px; display: flex; justify-content: center; align-items: center;
            backdrop-filter: blur(4px);
        }
        .touch-btn:active, .touch-btn.active { background: rgba(0, 255, 255, 0.3); border-color: #0ff; transform: scale(0.9); }
        #btn-action { width: 90px; height: 90px; border-color: rgba(0, 255, 255, 0.6); background: rgba(0, 255, 255, 0.1); }
    </style>
</head>
<body>

<div id="ui-layer">
    <div id="game-title">RUN</div>
    <div id="score">0m</div>
    <div id="high-score">BEST: 0m</div>
</div>
<div id="dash-indicator"></div>

<div id="game-over">
    <h1>WASTED</h1>
    <p id="final-score" style="font-size: 30px; font-weight: bold; margin: 20px 0; color: #fff;">0m</p>
    <button class="restart-btn" onclick="resetGame()">AGAIN</button>
</div>

<div id="mobile-controls">
    <div class="control-group">
        <div id="btn-left" class="touch-btn">←</div>
        <div id="btn-right" class="touch-btn">→</div>
    </div>
    <div class="control-group">
        <div id="btn-action" class="touch-btn">JUMP</div>
    </div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
/**
 * RUN - GAME LOGIC
 * Updates:
 * 1. Raycast Shooting (Directional) instead of Point-Click
 * 2. New Title "RUN"
 * 3. Additional Map Patterns
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// --- Game Constants ---
const GRAVITY = 0.65;
const FRICTION = 0.96; 
const GROUND_FRICTION = 0.85;
const MOVE_ACCEL = 0.6;
const JUMP_FORCE = -13;
const WALL_JUMP_FORCE = { x: 12, y: -15 };
const DASH_FORCE = 18; 
const MAX_SPEED = 28;
const MAX_ROPE_LENGTH = 700; // 사거리 약간 증가

// Camera & Juice
const CAMERA_SMOOTH_X = 0.08;
const CAMERA_SMOOTH_Y = 0.1;
let screenShake = 0; 

// --- Save System ---
let highScore = localStorage.getItem('runHighScore') || 0;
document.getElementById('high-score').innerText = `BEST: ${highScore}m`;

// --- Game State ---
let gameState = 'playing'; 
let frameCount = 0;
let score = 0;
let cameraX = 0;
let cameraY = 0;
let chaserX = -600; 

// --- Input Handling ---
const keys = { ArrowRight: false, ArrowLeft: false, Space: false };
let mousePos = { x: 0, y: 0 }; 

// Keyboard
window.addEventListener('keydown', (e) => {
    if(e.code === 'Space') keys.Space = true; 
    if(e.code === 'ArrowRight') keys.ArrowRight = true;
    if(e.code === 'ArrowLeft') keys.ArrowLeft = true;
});
window.addEventListener('keyup', (e) => {
    if(e.code === 'Space') keys.Space = false;
    if(e.code === 'ArrowRight') keys.ArrowRight = false;
    if(e.code === 'ArrowLeft') keys.ArrowLeft = false;
});

// Mouse Aim & Shoot
window.addEventListener('mousemove', (e) => {
    mousePos.x = e.clientX;
    mousePos.y = e.clientY;
});
window.addEventListener('mousedown', (e) => {
    if (gameState === 'playing') {
        const targetX = e.clientX + cameraX;
        const targetY = e.clientY + cameraY;
        player.shootRopeDirectional(targetX, targetY);
    }
});
window.addEventListener('mouseup', () => {
    player.releaseRope();
});

// Touch UI
function setupTouchBtn(id, keyCode) {
    const btn = document.getElementById(id);
    const handleStart = (e) => { e.preventDefault(); e.stopPropagation(); keys[keyCode] = true; btn.classList.add('active'); };
    const handleEnd = (e) => { e.preventDefault(); e.stopPropagation(); keys[keyCode] = false; btn.classList.remove('active'); };
    btn.addEventListener('touchstart', handleStart, {passive: false});
    btn.addEventListener('touchend', handleEnd, {passive: false});
}
setupTouchBtn('btn-left', 'ArrowLeft');
setupTouchBtn('btn-right', 'ArrowRight');
setupTouchBtn('btn-action', 'Space');

// Touch Canvas (Shooting)
canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    for (let i = 0; i < e.changedTouches.length; i++) {
        const t = e.changedTouches[i];
        const targetX = t.clientX + cameraX;
        const targetY = t.clientY + cameraY;
        player.shootRopeDirectional(targetX, targetY);
    }
}, {passive: false});

canvas.addEventListener('touchend', (e) => {
    e.preventDefault();
    player.releaseRope();
});


// --- Physics Helper: Ray vs Rect ---
function rayRectIntersect(x1, y1, x2, y2, rx, ry, rw, rh) {
    // x1,y1: start, x2,y2: end
    // Checks intersection of line segment (x1,y1)->(x2,y2) with rect
    
    let minT = Infinity;
    let hitPoint = null;

    const checkSeg = (x3, y3, x4, y4) => {
        const den = (y4-y3)*(x2-x1) - (x4-x3)*(y2-y1);
        if (den === 0) return;
        const ua = ((x4-x3)*(y1-y3) - (y4-y3)*(x1-x3)) / den;
        const ub = ((x2-x1)*(y1-y3) - (y2-y1)*(x1-x3)) / den;
        if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
            if (ua < minT) {
                minT = ua;
                hitPoint = { x: x1 + ua*(x2-x1), y: y1 + ua*(y2-y1) };
            }
        }
    };

    // Check 4 sides
    checkSeg(rx, ry, rx+rw, ry);       // Top
    checkSeg(rx, ry+rh, rx+rw, ry+rh); // Bottom
    checkSeg(rx, ry, rx, ry+rh);       // Left
    checkSeg(rx+rw, ry, rx+rw, ry+rh); // Right

    return hitPoint;
}

// --- Player Class ---
class Player {
    constructor() {
        this.x = 200;
        this.y = 0;
        this.w = 20;
        this.h = 40;
        this.vx = 0;
        this.vy = 0;
        this.onGround = false;
        this.onWall = 0; 
        this.rope = null; 
        this.canDash = true; 
        this.lastSpaceRelease = true;
        this.facing = 1;
        this.trail = [];
    }

    get centerX() { return this.x + this.w/2; }
    get centerY() { return this.y + this.h/2; }

    update() {
        if (keys.ArrowRight) this.facing = 1;
        if (keys.ArrowLeft) this.facing = -1;

        // --- Rope Mechanics ---
        if (this.rope) {
            const dx = this.x - this.rope.x;
            const dy = this.y - this.rope.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            const angle = Math.atan2(dy, dx);

            this.vx += Math.sin(angle) * 0.25; 
            if (keys.ArrowRight) this.vx += 0.45; 
            if (keys.ArrowLeft) this.vx -= 0.45;

            if (dist > this.rope.length) {
                const force = (dist - this.rope.length) * 0.2; 
                this.vx -= Math.cos(angle) * force;
                this.vy -= Math.sin(angle) * force;
                this.vx *= 0.99;
                this.vy *= 0.99;
            }
        } 
        else {
            if (keys.ArrowRight) this.vx += MOVE_ACCEL;
            if (keys.ArrowLeft) this.vx -= MOVE_ACCEL;
            
            this.vy += GRAVITY;

            if (this.onWall !== 0 && !this.onGround) {
                if (this.vy > 3) this.vy = 3; 
                this.canDash = true; 
                if (keys.Space && this.lastSpaceRelease) {
                    this.vy = WALL_JUMP_FORCE.y;
                    this.vx = -this.onWall * WALL_JUMP_FORCE.x; 
                    this.onWall = 0;
                    this.lastSpaceRelease = false;
                    createParticles(this.x, this.y + 20, '#fff', 8);
                }
            } 
            else if (this.onGround && keys.Space && this.lastSpaceRelease) {
                this.vy = JUMP_FORCE;
                this.onGround = false;
                this.lastSpaceRelease = false;
            } 
            else if (!this.onGround && keys.Space && this.lastSpaceRelease && this.canDash) {
                this.performDash();
                this.lastSpaceRelease = false;
            }
        }

        if (this.onGround) {
            this.vx *= GROUND_FRICTION;
            this.canDash = true;
        } else {
            this.vx *= FRICTION;
        }

        if (Math.abs(this.vx) > MAX_SPEED) {
            this.vx = (this.vx > 0 ? 1 : -1) * MAX_SPEED;
        }

        this.x += this.vx;
        this.y += this.vy;

        if (!keys.Space) this.lastSpaceRelease = true;

        // Death
        if (this.y > 3000 || this.x < chaserX + 50) {
            die();
        }

        // Trail
        if (Math.abs(this.vx) > 15 || this.rope) {
            if (frameCount % 2 === 0) {
                this.trail.push({x: this.x, y: this.y, alpha: 0.6, w: this.w, h: this.h});
                if (this.trail.length > 8) this.trail.shift();
            }
        }
    }

    shootRopeDirectional(targetX, targetY) {
        // 1. Calculate direction vector from player center
        const dx = targetX - this.centerX;
        const dy = targetY - this.centerY;
        const angle = Math.atan2(dy, dx);

        // 2. Define Ray End Point (Max Range)
        const rayEndX = this.centerX + Math.cos(angle) * MAX_ROPE_LENGTH;
        const rayEndY = this.centerY + Math.sin(angle) * MAX_ROPE_LENGTH;

        // 3. Raycast against all platforms
        let bestHit = null;
        let minHitDist = Infinity;

        for (let p of platforms) {
            // Optimization
            if (Math.abs(p.x - this.x) > MAX_ROPE_LENGTH) continue;

            const hit = rayRectIntersect(
                this.centerX, this.centerY,
                rayEndX, rayEndY,
                p.x, p.y, p.w, p.h
            );

            if (hit) {
                const d = (hit.x - this.centerX)**2 + (hit.y - this.centerY)**2;
                if (d < minHitDist) {
                    minHitDist = d;
                    bestHit = hit;
                }
            }
        }

        if (bestHit) {
            this.rope = { x: bestHit.x, y: bestHit.y, length: Math.sqrt(minHitDist) };
            
            // Juice
            screenShake = 8; 
            createParticles(bestHit.x, bestHit.y, '#0ff', 15); 
            createShockwave(bestHit.x, bestHit.y); 
        } else {
            // Miss Effect (Shoot a short line to show direction)
            createParticles(this.centerX + Math.cos(angle)*50, this.centerY + Math.sin(angle)*50, '#555', 3);
        }
    }

    releaseRope() {
        if(this.rope) {
            this.rope = null;
            this.vx *= 1.1; 
            this.vy *= 1.1;
            this.canDash = true; 
        }
    }

    performDash() {
        this.vx = this.facing * DASH_FORCE; 
        this.vy = -4; 
        this.canDash = false;
        createParticles(this.x + 10, this.y + 20, '#0ff', 15);
        const indicator = document.getElementById('dash-indicator');
        indicator.classList.remove('ready');
    }

    draw() {
        // Trail
        this.trail.forEach(t => {
            ctx.fillStyle = `rgba(0, 255, 255, ${t.alpha * 0.4})`;
            ctx.fillRect(t.x - cameraX, t.y - cameraY, t.w, t.h);
            t.alpha -= 0.05;
        });

        // Rope
        if (this.rope) {
            ctx.beginPath();
            ctx.moveTo(this.centerX - cameraX, this.centerY - cameraY);
            ctx.lineTo(this.rope.x - cameraX, this.rope.y - cameraY);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            ctx.beginPath();
            ctx.arc(this.rope.x - cameraX, this.rope.y - cameraY, 6, 0, Math.PI*2);
            ctx.fillStyle = '#fff';
            ctx.fill();
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#0ff';
            ctx.stroke();
            ctx.shadowBlur = 0;
        }

        // Player
        ctx.fillStyle = this.canDash ? '#fff' : '#0aa'; 
        if (this.canDash) {
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#0ff';
        }
        ctx.fillRect(this.x - cameraX, this.y - cameraY, this.w, this.h);
        ctx.shadowBlur = 0;

        const indicator = document.getElementById('dash-indicator');
        if (this.canDash && !indicator.classList.contains('ready')) indicator.classList.add('ready');
        if (!this.canDash && indicator.classList.contains('ready')) indicator.classList.remove('ready');

        // Aim Guide (Simple line)
        if (!this.rope) {
            const cx = mousePos.x;
            const cy = mousePos.y;
            const dx = cx - (this.centerX - cameraX);
            const dy = cy - (this.centerY - cameraY);
            const angle = Math.atan2(dy, dx);
            
            ctx.beginPath();
            ctx.moveTo(this.centerX - cameraX, this.centerY - cameraY);
            ctx.lineTo(
                (this.centerX - cameraX) + Math.cos(angle) * 50,
                (this.centerY - cameraY) + Math.sin(angle) * 50
            );
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
    }
}

// --- World Generation (New Patterns) ---
let platforms = [];
let particles = [];
let shockwaves = [];
let nextSpawnX = 0;

const patterns = [
    (startX) => { // Basic
        let x = startX;
        let baseY = Math.random() * 500;
        platforms.push({x: x, y: baseY + 500, w: 800, h: 100, type: 'floor'});
        platforms.push({x: x + 200, y: baseY + 200, w: 100, h: 20, type: 'ceil'});
        platforms.push({x: x + 500, y: baseY + 150, w: 100, h: 20, type: 'ceil'});
        return x + 900;
    },
    (startX) => { // Skyscrapers
        let x = startX;
        let baseY = Math.random() * 500;
        for(let i=0; i<3; i++) {
            let h = 400 + Math.random() * 200;
            let y = baseY + 500 - h;
            platforms.push({x: x, y: y, w: 60, h: h, type: 'wall'});
            platforms.push({x: x - 100, y: y - 150, w: 260, h: 20, type: 'ceil'});
            x += 350; 
        }
        return x + 100;
    },
    (startX) => { // The Tunnel (New)
        let x = startX;
        let baseY = Math.random() * 500 + 200;
        // Floor
        platforms.push({x: x, y: baseY, w: 1200, h: 50, type: 'floor'});
        // Ceiling
        platforms.push({x: x, y: baseY - 250, w: 1200, h: 50, type: 'ceil'});
        // Obstacles inside
        platforms.push({x: x + 400, y: baseY - 50, w: 50, h: 50, type: 'wall'});
        platforms.push({x: x + 800, y: baseY - 200, w: 50, h: 100, type: 'wall'});
        return x + 1250;
    },
    (startX) => { // Stairs (New)
        let x = startX;
        let y = Math.random() * 500 + 300;
        for(let i=0; i<6; i++) {
            platforms.push({x: x, y: y, w: 100, h: 40, type: 'floor'});
            x += 180;
            y -= 60; // Upwards
        }
        return x + 100;
    },
    (startX) => { // Pillars Forest (New)
        let x = startX;
        let baseY = Math.random() * 500;
        for(let i=0; i<5; i++) {
            platforms.push({x: x, y: baseY, w: 40, h: 600, type: 'wall'}); // Tall thin walls
            x += 250;
        }
        return x + 100;
    }
];

function generateWorld() {
    platforms = platforms.filter(p => p.x + p.w > cameraX - 200);
    while (nextSpawnX < cameraX + canvas.width + 1500) {
        const patternFunc = patterns[Math.floor(Math.random() * patterns.length)];
        nextSpawnX = patternFunc(nextSpawnX);
    }
}

function checkCollisions(player) {
    player.onGround = false;
    player.onWall = 0;
    for (let p of platforms) {
        if (player.x < p.x + p.w && player.x + player.w > p.x &&
            player.y < p.y + p.h && player.y + player.h > p.y) {
            
            let overlapX = (player.w + p.w) / 2 - Math.abs((player.centerX) - (p.x + p.w/2));
            let overlapY = (player.h + p.h) / 2 - Math.abs((player.centerY) - (p.y + p.h/2));

            if (overlapX < overlapY) {
                if (player.x < p.x) { player.x = p.x - player.w; player.onWall = 1; } 
                else { player.x = p.x + p.w; player.onWall = -1; }
                player.vx = 0;
            } else {
                if (player.y < p.y) {
                    player.y = p.y - player.h;
                    player.vy = 0;
                    player.onGround = true;
                    player.rope = null; 
                } else {
                    player.y = p.y + p.h;
                    player.vy *= -0.5;
                }
            }
        }
    }
}

// --- Effects ---
function createParticles(x, y, color, count) {
    for(let i=0; i<count; i++) {
        particles.push({
            x: x, y: y, vx: (Math.random() - 0.5) * 15, vy: (Math.random() - 0.5) * 15,
            life: 1.0, color: color, size: Math.random() * 4 + 1
        });
    }
}

function createShockwave(x, y) {
    shockwaves.push({x: x, y: y, r: 1, alpha: 1.0});
}

function updateAndDrawEffects() {
    for(let i=particles.length-1; i>=0; i--) {
        let p = particles[i];
        p.x += p.vx; p.y += p.vy; p.life -= 0.04;
        if(p.life <= 0) particles.splice(i, 1);
        else {
            ctx.fillStyle = p.color;
            ctx.globalAlpha = p.life;
            ctx.fillRect(p.x - cameraX, p.y - cameraY, p.size, p.size);
            ctx.globalAlpha = 1.0;
        }
    }
    for(let i=shockwaves.length-1; i>=0; i--) {
        let s = shockwaves[i];
        s.r += 3;
        s.alpha -= 0.05;
        if(s.alpha <= 0) shockwaves.splice(i, 1);
        else {
            ctx.beginPath();
            ctx.arc(s.x - cameraX, s.y - cameraY, s.r, 0, Math.PI*2);
            ctx.strokeStyle = `rgba(255, 255, 255, ${s.alpha})`;
            ctx.lineWidth = 3;
            ctx.stroke();
        }
    }
}

// --- Main Loop ---
const player = new Player();

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// Init
platforms.push({x: 0, y: 500, w: 1000, h: 100, type: 'floor'});
nextSpawnX = 1000;

function loop() {
    // Screen Shake
    let shakeX = 0;
    let shakeY = 0;
    if (screenShake > 0) {
        shakeX = (Math.random() - 0.5) * screenShake;
        shakeY = (Math.random() - 0.5) * screenShake;
        screenShake *= 0.9;
        if(screenShake < 0.5) screenShake = 0;
    }

    ctx.save();
    ctx.translate(shakeX, shakeY);

    if (gameState === 'playing') {
        player.update();
        checkCollisions(player);
        generateWorld();
        
        let targetCamX = player.x - canvas.width * 0.25;
        cameraX += (targetCamX - cameraX) * CAMERA_SMOOTH_X;
        let targetCamY = player.y - canvas.height * 0.6;
        cameraY += (targetCamY - cameraY) * CAMERA_SMOOTH_Y;

        let chaserSpeed = 6 + (score / 800); 
        if (chaserSpeed > player.vx && player.vx > 0) chaserSpeed = player.vx * 0.95; 
        chaserX += chaserSpeed;
        if (chaserX < cameraX - 400) chaserX = cameraX - 400; 

        score = Math.floor(player.x / 10);
        document.getElementById('score').innerText = `${score}m`;
    }

    // Render
    ctx.clearRect(-shakeX, -shakeY, canvas.width, canvas.height);
    ctx.fillStyle = '#050505'; 
    ctx.fillRect(-shakeX, -shakeY, canvas.width, canvas.height);

    // Chaser
    let chaserScreenX = chaserX - cameraX;
    let gradient = ctx.createLinearGradient(chaserScreenX, 0, chaserScreenX + 500, 0);
    gradient.addColorStop(0, 'rgba(200, 0, 0, 0.9)');
    gradient.addColorStop(1, 'rgba(200, 0, 0, 0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(-shakeX, -shakeY, canvas.width, canvas.height); 

    // Platforms
    ctx.strokeStyle = '#444';
    platforms.forEach(p => {
        if (p.x + p.w > cameraX && p.x < cameraX + canvas.width &&
            p.y + p.h > cameraY && p.y < cameraY + canvas.height) {
            
            ctx.fillStyle = p.type === 'wall' ? '#222' : '#111';
            ctx.fillRect(p.x - cameraX, p.y - cameraY, p.w, p.h);
            ctx.strokeRect(p.x - cameraX, p.y - cameraY, p.w, p.h);
            
            if(p.type === 'wall') {
                ctx.fillStyle = '#f00';
                ctx.fillRect(p.x - cameraX + 5, p.y - cameraY + 10, 3, p.h - 20);
            }
            if(p.type === 'ceil') {
                ctx.fillStyle = '#0f0';
                ctx.fillRect(p.x - cameraX + 10, p.y - cameraY + p.h - 5, p.w - 20, 2);
            }
        }
    });

    updateAndDrawEffects();
    player.draw();

    ctx.restore(); 

    frameCount++;
    requestAnimationFrame(loop);
}

function die() {
    gameState = 'gameover';
    if (score > highScore) {
        highScore = score;
        localStorage.setItem('runHighScore', highScore);
    }
    document.getElementById('game-over').style.display = 'block';
    document.getElementById('final-score').innerText = `${score}m`;
}

function resetGame() {
    player.x = 200;
    player.y = 0;
    player.vx = 0;
    player.vy = 0;
    player.rope = null;
    player.canDash = true;
    
    platforms = [];
    particles = [];
    shockwaves = [];
    platforms.push({x: 0, y: 500, w: 1000, h: 100, type: 'floor'});
    nextSpawnX = 1000;
    
    cameraX = 0;
    cameraY = 0;
    chaserX = -600;
    score = 0;
    gameState = 'playing';
    document.getElementById('game-over').style.display = 'none';
}

loop();

</script>
</body>
</html>
